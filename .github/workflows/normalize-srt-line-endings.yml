name: Normalize web/web.srt line endings to LF

on:
  push:
    paths:
      - 'web/web.srt'

permissions:
  contents: write

jobs:
  normalize-srt:
    runs-on: ubuntu-latest
    outputs:
      changed: ${{ steps.check.outputs.changed }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # 保留完整历史以便读取最近提交信息
          fetch-depth: 0

      - name: Get last commit info for web/web.srt
        id: last_commit
        run: |
          FILE=web/web.srt

          # 尝试获取最近修改该文件的完整提交信息 (subject + body)
          LAST_COMMIT_MSG=$(git log -n 1 --pretty=format:%B -- "$FILE" || true)
          if [ -z "$LAST_COMMIT_MSG" ]; then
            LAST_COMMIT_MSG="Normalize line endings in web/web.srt"
          fi
          # 将完整 message 写入文件，避免通过 outputs 传递多行文本
          echo "$LAST_COMMIT_MSG" > commit_message.txt

          # 获取最后修改该文件的作者信息（name/email）
          LAST_AUTHOR_NAME=$(git log -n 1 --pretty=format:%an -- "$FILE" || echo "GitHub Actions")
          LAST_AUTHOR_EMAIL=$(git log -n 1 --pretty=format:%ae -- "$FILE" || echo "actions@github.com")

          # 导出信息（注意：message 写入文件，输出只传递文件名）
          echo "::set-output name=message_file::commit_message.txt"
          echo "::set-output name=author_name::${LAST_AUTHOR_NAME}"
          echo "::set-output name=author_email::${LAST_AUTHOR_EMAIL}"

      - name: Check and normalize line endings
        id: check
        run: |
          FILE=web/web.srt
          if [ ! -f "$FILE" ]; then
            echo "file_missing=true" >> $GITHUB_OUTPUT
            echo "changed=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # 检查是否存在 CRLF (\r\n 或 \r)
          if grep -q $'\r' "$FILE"; then
            # 将 CRLF 和孤立 CR 转为 LF
            # 使用 perl 处理整个文件（-0777 使其以单个字符串处理）
            perl -0777 -pe 's/\r\n/\n/g; s/\r/\n/g' "$FILE" > "${FILE}.normalized"
            mv "${FILE}.normalized" "$FILE"
            git add "$FILE"
            echo "changed=true" >> $GITHUB_OUTPUT
          else
            echo "changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Commit and force-push if changed
        if: steps.check.outputs.changed == 'true'
        env:
          MESSAGE_FILE: ${{ steps.last_commit.outputs.message_file }}
          ORIGINAL_AUTHOR_NAME: ${{ steps.last_commit.outputs.author_name }}
          ORIGINAL_AUTHOR_EMAIL: ${{ steps.last_commit.outputs.author_email }}
        run: |
          FILE=web/web.srt

          # 配置 committer（可用 actions bot）
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # 使用原作者作为 author，并用 -F 指定包含完整 message 的文件（保留 subject + body）
          if [ ! -f "${MESSAGE_FILE}" ]; then
            echo "Message file ${MESSAGE_FILE} not found, aborting."
            exit 1
          fi

          GIT_AUTHOR_NAME="${ORIGINAL_AUTHOR_NAME}" GIT_AUTHOR_EMAIL="${ORIGINAL_AUTHOR_EMAIL}" \
            git commit -F "${MESSAGE_FILE}" -- "$FILE" || { echo "commit failed or nothing to commit"; exit 1; }

          # 强制推送当前分支以覆盖远端（risky）
          BRANCH="${GITHUB_REF#refs/heads/}"
          git push "https://${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git" "HEAD:${BRANCH}" --force

